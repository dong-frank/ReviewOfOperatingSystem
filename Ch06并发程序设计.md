# Ch06并发程序设计

## 并发进程

### 并发程序设计的概念
顺序执行
- 程序是实现算法的操作序列
- 每个程序在处理器上执行是严格有序的
- 称为程序执行的内部顺序性

程序设计的一般习惯是顺序程序设计
- 把一个具体问题的求解过程设计成一个程序或者严格顺序执行的程序序列
- 这称为程序执行的外部顺序性

顺序程序设计特征
- 顺序性: 程序指令执行严格按序
- 封闭性: 程序运行时如同独占操作系统保护的资源
- 确定性: 结果和执行速度和执行时段无关
- 可再现性: 程序对相同数据集的执行轨迹是确定的

进程的并发执行
- 多道程序设计让多个程序同时进入内存竞争处理器
- OS允许多个进程并发执行
- OS保证按照"顺序程序设计"方法编制的程序在并发执行时不受影响,如同独占计算机
- 按照顺序程序设计思想编制的进程在OS中并发执行属于无关的并发进程


并发程序设计
- 进程的并发性是指一组进程的执行在时间上是重叠的
- 宏观上看, 并发性反映一个时间段中几个进程都在同一处理器上, 处于运行还未结束状态
- 微观上看, 任一时刻仅有一个进程在处理器上运行
- 使一个程序分成若干可同时执行的程序模块的方法称并发程序设计, 每个程序模块和它执行时处理的数据就组成一个进程

并发程序设计特征
- 并行性: 多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行 **提高了计算效率**
- 共享性: 多个进程共享软件资源
- 交往性: 多个进程并发执行时存在制约 **增加了程序设计的难度**

### 并发进程的制约关系
并发进程分类
- 无关的: 一组并发进程分别在不同的变量集合上运行, 是进程的执行和时间无关的一个充分条件, 又成为**Bernstein条件**
- 交往的: 一组并发进程共享某些变量, 一个进程的执行可能影响其他并发进程的结果, 不满足Bernstein条件

Bernstein条件
- $R(p_i)=\{a_i,...\}$, 程序$p_i$在执行期间引用的变量
- $W(p_i)=\{b_i,...\}$, 程序$p_i$在执行期间改变的变量
- $(R(p_1) \cap W(p_2))\cup (W(p_1) \cap R(p_2)) \cup (W(p_1) \cap W(p_2)) = \phi$
- 则并发进程的执行与时间无关

与时间有关的错误
- 对于一组交往的并发进程, 执行的相对速度无法相互控制
- 如果设计不当, 可能出现时间有关的错误
  - 结果错误
  - 永远等待

进程的交互
- 进程之间存在两种基本关系
- 竞争关系, 两个进程要访问同一资源
- 协作关系, 某些进程为完成同一任务需要分工协作

#### 竞争关系
竞争关系带来两个控制问题
- 死锁问题
- 饥饿问题

进程的互斥(mutual exclusion)是解决进程间竞争关系的手段(间接制约手段)
- 若干进程要使用同一共享资源时, 任何时刻最多允许一个进程去使用
- 其他要使用该资源的进程必须等待, 直到占有资源的进程释放

#### 协作关系
需要相互协作的进程在某些协调点上协调各自的工作, 先到达协调点的要等待其他进程

进程的同步(synchronizatio)是解决进程间协作关系的手段(直接制约手段)
- 两个或两个以上的进程基于某个条件来协调他们的活动
- 一个进程的执行依赖于另一个协作进程的消息或信号
- 当一个进程没有得到来自另一个进程的消息或信号时则需等待
- 直到消息或信号到达才被唤醒

**进程互斥是一种特殊的进程同步**, 即逐次使用互斥共享资源, 是对进程使用资源次序上的一种协调

## 临界区管理

### 临界区
临界资源: 互斥共享变量所代表的资源
- 即一次只能被一个进程使用的资源
- 临界区指并非进程中与互斥共享变量相关的程序段
- 如果两个进程同时停留在相关的临界区内, 就会出现与时间有关的错误
- 若两个进程的临界区有相同的临界资源, 就是相关的临界区, 必须互斥进入
- 若两个临界区不相关, 进入就没有限制

临界区管理有三个要求
- 一次至多允许一个进程停留
- 一个进程不能无限地停留
- 一个进程不能无限地等待进入

### 临界区管理实现的尝试
Peterson算法

### 临界区管理实现的硬件方式
硬件设施
- 关中断
- 测试并建立指令
- 对换指令


#### 关中断
- 实现互斥的最简单方法
- 关闭中断后就无法进行进程的切换了, 自然实现了互斥的目的

#### 测试并建立指令
- 一条TS指令
- 测试当前条件变量的真假值

#### 对换指令
- 一条SWAP指令
- 交换两个条件变量的值

总结
- TS和SWAP指令均是忙式等待(在while循环中), 效率低
- 简单的解决办法是在进出临界区时开关中断
> 关中断; 临界区; 开中断
- 操作系统的原语就采用这种实现思路
- 但是临界区的指令长度不能太长, 这样才能保证系统效率
- 不建议用户程序使用

## PV操作

### PV操作与进程互斥
对不能进入临界区的进程采用忙式等待测试法, 浪费CPU时间

通用的解决方案: 信号量与PV操作

一个进程在某一特殊点上被迫停止执行直到接受到一个对应的特殊变量值(信号量)

#### 信号量数据结构定义
设s为一个记录型数据结构, 一个分量为整数量value, 另一个为信号量队列queue, P和V操作原语定义
- P(s), 将value-1, 若结果小于0, 则将调用P(s)的进程阻塞, 进入信号量队列
- V(s), 将value+1, 若结果不大于0, 则唤醒一个队列中的进程
- 强调对于信号量只允许使用P和V操作访问
- 不同的进程请求的是不同的资源, 所以会进入不同的信号量等待队列

关于信号量与PV操作的推论
- 若s的value为正值, 表示实际还可以使用的物理资源数
- 若s的value为负值, 绝对值代表队列中等待的进程个数
- P操作意味着请求一个资源, V操作意味着释放一个资源
- 在一定条件下, P操作代表阻塞进程, V操作代表唤醒进程

#### 信号量的应用
在表达纯粹的互斥关系时, 信号量初值为1, 且同一个信号量的P和V处于同一侧进程

> 哲学家就餐问题

关于如何避免哲学家就餐问题的死锁

首先是为什么会死锁, 因为取左右手叉子之间的操作存在缝隙, 会出现时间有关的错误

解决办法
1. 至多允许四个哲学家同时取叉子, 新增一个表示房间的信号量, 初始值为4
2. 规定偶数哲学家先取右手的叉子, 奇数哲学家先取左手的叉子
3. 每个哲学家取到两把叉子才吃, 否则就把叉子放回

求解同步问题, 同一个信号量的P和V就不能位于同一侧进程, 要分别位于协作的两个进程

> 生产者与消费者

对于生产者和消费者之间, 他们是协作的进程, 解决同步问题

但对于多个生产者之间或多个消费者之间, 他们内部是竞争关系, 要解决互斥问题

## 管程

### 管程概述
为什么要引入管程
- 把分散在各进程中的临界区集中起来进行管理
- 防止进程有意或无意的违法同步操作
- 便于高级语言来书写程序

管程的定义
- 管程是由局部于自己的若干公共变量及其说明, 和所有访问这些公共变量的过程所组成的软件模块

管程的属性
- 共享性
- 安全性
- 互斥性

管程的基本形式
```
type 管程名 = monitor{
  局部变量说明;
  条件变量说明;
  初始化语句;
  InterfaceModule IM;
  define 管程内定义的, 在管程外可调用的过程列表
  use 管程外定义的, 管程内将调用的过程列表

  过程名(形式参数){
    <过程>
  }
  ...
}
```

管程的条件变量
- 条件变量是出现在管程内的一种数据结构, 只有在管程中才能被访问, 对管程内的所有过程是全局的, 只能通过两个原语操作来控制
- 是当调用管程过程的进程无法运行时, 用于阻塞进程的信号量
- wait(), 当一个管程的过程发现无法继续时, 在某些条件变量上执行wait, 引起调用管程的进程阻塞
- signal(), 如果存在其他进程由于wait()被阻塞, 便释放, 如果没有等待的, 那么什么也不做(**注意和V操作区分**), 用于释放在某些条件变量上阻塞的进程

当使用signal()后, 这时候可能出现两个进程同时停留在管程, 解决方法
1. 执行signal的进程等待, 直到被释放进程退出管程, 或等待另一个signal信号
2. 被释放进程等待, 直到执行signal的进程退出管程, 或等待另一个signal信号

霍尔采用第一种办法, 称为霍尔管程

汉森选择两者折中, 规定管程中的过程中的signal()必须是过程体的最后一个操作, 这样就相当于执行signal()的进程就会自动退出管程

### 霍尔管程
霍尔管程使用P和V来实现对管程中的过程的互斥调用, 及实现对共享资源互斥使用的管理

不要求signal()是过程的最后一个操作, 且wait()和signal()被设计成可以中断的过程

#### 霍尔管程数据结构
1. 信号量mutex, 用于管程中过程的互斥调用
   1. 调用管程中的任何过程前都应执行P(mutex)
   2. 退出管程时, 需要判断是否有进程在next信号量等待
   3. 如果有, 则通过V(next)唤醒一个之前发出signal的进程(发出signal的进程会等待)
   4. 否则执行V(mutex)开放管程, 让其他进程可以调用
   5. 进程等待资源期间, 即wait()操作被阻塞后, 如果其他进程无法进入管程, 也就自然无法归还资源, 会导致无限等待, 所以要在wait()操作中执行V(mutex)
2. 信号量next(初始为0), 和局部变量next_count
   1. 发出signal()的进程用P(next)阻塞自身
   2. 用next_count来记录进程退出管程的时候是否有因为signal()阻塞的进程需要唤醒
3. 信号量x_sem(初始为0), 和局部变量x_count
   1. 申请资源得不到满足时, 执行的是P(x_sem)阻塞, 且x_count增加
   2. 释放资源时, 需要知道是否有别的进程在等待资源, 即查看x_count
   3. 执行signal()时, 应该让先前已经进入管程在等待资源的进程恢复, 而不应让其他进程进入管程, 所以用V(x_sem)实现, 而不能V(mutex)

一个重要的误区: 管程中只能有一个进程, 因为wait()阻塞的也相当于退出了管程, 只不过wait()阻塞后应该优先被signal唤醒, 重新进入管程

#### 霍尔管程的实现
```
void enter(InterfaceModule IM){
  P(m.mutex); //调用管程中的任何过程前都应执行P(mutex)
}
```

```
void leave(Monitor m){
  if(m.next_count > 0) {
    //有发出过signal的进程, 把他们唤醒
    V(m.next);
  }else {
    //没有, 就开放管程给所有进程
    V(mutex);
  }
}
```

```
void wait(semaphore &x_sem, int &x_count,InterfaceModule IM){ //这里要传入参数因为要指明是哪种资源
  x_count++; //等x资源的进程增加1
  
  //相当于暂时退出了管程
  if(IM.next_count > 0) {
    //有发出过signal的进程, 把他们唤醒
    V(IM.next);
  }else {
    //没有, 就开放管程给所有进程
    V(mutex);
  }

  P(x_sem); //阻塞自身

  x_count--; //能执行到这的时候说明阻塞结束, 即等到了资源
}
```

```
void signal (semaphore &x_sem, int &x_count, InterfaceModule IM){
  if(x_count > 0){
    //有正在等待x资源的进程
    IM.next_count++; //发出signal进程的要放入next等待队列
    V(x_sem); //唤醒等待的那个进程
    P(IM.next); //阻塞自己

    IM.next_count--; //能执行到这的时候说明阻塞结束, 即之前的进程已退出管程
  }
}
```


## 进程通信
交往进程通过信号量操作实现进程互斥和同步, 是一种低级通信方式

进程有时候还需要交换更多的信息, 如数据, 引进高级通信方式, 进程通信机制, 实现进程间用信件来交换信息

当进程互相交互时, 必须满足两个基本要求
- 同步: 为实施互斥, 进程间需要同步
- 通信: 为了协作, 进程间需要交换信息

### 进程直接通信
对称直接寻址
- 发送和接受进程必须命名对方
- send(P, message)
- receive(Q, message)

非对称直接寻址
- 只要发送者命名接收者
- send(P, message)
- receive(id, message) 接收来自任何进程的消息, 变量id会置成与其通信的进程名称

### 进程间接通信
信息不是直接从发送者发送到接收者, 而是发送到由临时保存这些消息的队列组成的一个共享数据结构, 这些队列通常称为信箱
- 一个进程给合适的信箱发送消息, 另一个进程从中取出
- send(A, message)
- receive(A, message)

类似生产者和消费者的问题

### 高级进程通信机制
基于流的进程通信
- 多个进程使用一个共享的信息缓冲区(可称为管道, 多路转接字, 套接字)
- 信息交换单位基于字符流, 长度任意

基于RPC的高级通信规约(远程过程调用)
- 采用客户端/服务器计算模式
- 服务器进程提供一系列过程, 供客户端调用
- 客户端通过调用服务器进程提供的过程, 获得服务


## 死锁

### 死锁的产生
- 进程推进顺序不当产生死锁
- PV操作使用不当
- 资源分配不当
- 对临时性资源使用不加限制

死锁定义
- 如果一个进程集合中的每个进程都在等待只能由该集合中的其他一个进程才能引发的事件
- 则称一组进程或系统此时发生死锁

产生死锁的因素
- 不仅与系统拥有的资源数量有关
- 而且与资源分配策略, 进程对资源的使用要求, 以及并发进程的推进顺序有关

### 死锁的防止
系统形成死锁的四个必要条件
- 互斥条件: 系统中存在临界资源, 进程应互斥地使用
- 占有和等待条件: 进程请求资源得不到满足而等待时, 不释放已占有的资源
- 不剥夺条件: 已被占用的资源只能主动释放, 不运行被其他进程剥夺
- 循环等待条件: 存在循环等待链

破坏第一个条件: 互斥条件
- 使资源可同时访问
- 但有些资源具有天生的互斥性

破坏第二个条件: 占有和等待条件
- 静态分配资源, 进程执行中不再申请资源
- 实现简单, 但会严重降低资源利用率

破坏第三个条件: 不剥夺条件
- 采用剥夺式调度方法, 如申请资源失败就主动释放资源

破坏第四个条件: 循环等待条件


层次分配策略 **破坏条件2和4**
- 资源被分成多个层次
- 当进程得到某一层的一个资源后, 只能再申请较高层次的资源
- 当进程要释放某层的一个资源时, 必须先释放占用的较高层次的资源
- 当进程得到某一层的一个资源后, 想申请另一个资源, 必须先释放掉该层中的已占资源

### 死锁的避免
银行家算法 *看具体例题*

### 死锁的检测和解除
资源分配图和死锁定理
- 解决死锁问题的一条途径是在分配的时候不加限制
- 但系统定时运行一个死锁检测程序
- 若发生死锁再采取措施解除

死锁的检测
- 如果进程-资源分配图中无环路, 则此时没有发生死锁
- 如果有环路, 且每个资源类中仅有一个资源, 则发生了死锁
- 如果有环路, 但每个资源类中有多个资源, 则不一定发生死锁

简化进程
- 在进程-资源分配图中, 如果能消去一个进程的所有请求边和分配边, 使其成为孤立结点, 这称为进程的简化
- 如果所有进程都可以简化, 则该图是可完全简化的
- 当进程-资源分配图是不可完全简化的, 那么系统就是死锁状态 **死锁定理**

死锁的解除
- 结束所有进程的执行, 重新启动OS
- 撤销陷于死锁的所有进程
- 逐个撤销陷于死锁的进程, 回收其资源重新分派
- 剥夺陷于死锁的进程占用的资源但不撤销
- 根据系统保存的检查点, 让所有进程回退
- 如果存在某些未卷入死锁的进程, 随着这些进程结束, 可能释放足够的资源解除死锁