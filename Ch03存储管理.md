# Ch03 存储管理

## 存储管理基础
### 基本概念
逻辑地址
- 又称相对地址, 即用户编程所使用的地址空间
- 从0开始编号, 有两种形式
  - 一维逻辑地址
  - 二维逻辑地址(段号 + 段内地址)

段式程序设计
- 把一个程序设计成多个段: 代码段, 数据段, 堆栈段等等
- 用户可以自己应用段覆盖技术扩充内存空间使用量 **是程序设计技术, 不是OS存储管理功能**

物理地址
- 又称绝对地址, 即程序执行所使用的地址空间
- 处理器执行指令时按照物理地址进行


### 存储管理的基本模式
主存储器的复用
- 多道程序设计需要复用主存
- 按分区复用
  - 主存划分为多个固定/可变的分区
  - 一个程序占用一个分区
- 按页框复用
  - 主存划分成多个固定大小的页框
  - 一个程序占用多个页框

存储管理的基本模式
1. 单连续存储管理: 一维逻辑地址空间的程序, 占用一个主存固定分区或可变分区
2. 段式存储管理: 段式二维逻辑地址空间的程序, 占用多个主存可变分区
3. 页式存储管理: 一维逻辑地址空间的程序占用多个主存页框
4. 段页式存储管理: 段式二维逻辑地址空间的程序占用多个主存页框

### 存储管理的功能

#### 地址转换
又称重定位, 即把逻辑地址转换成绝对地址
- 静态重定位: 在程序装入内存时进行地址转换, 由装入程序执行, 早期小型OS使用
- 动态重定位: 在CPU执行程序时进行地址转换, **由硬件地址转换机构完成**

#### 主存储器的分配与去配
分配: 进程装入主存时, 由存储管理软件进行具体的主存分配操作, 并设置一个表格记录主存空间的分配情况

去配: 当某个进程撤离或主动归还主存资源时, 存储管理软件要收回所占用的全部或部分存储空间, 调整主存分配表信息

#### 主存储器空间的共享
这个共享有多种含义
1. 多个进程共享主存储器资源, 他们各自占用一定数量的存储空间
2. 多个进程共享主存储器的某些区域, 因为有些进程是相同的程序块或相同的数据块, 他们共享主存的相同区域

#### 存储保护
为避免主存中的多个进程相互干扰, 必须对主存中的程序和数据进行保护
- 私有主存区的信息: 可读可写
- 公共区的共享信息: 根据授权
- 非本进程的信息: 不可读写

**这一功能需要软硬件协同完成**
- CPU检查是否允许访问
- 若不允许则产生地址保护异常, 由OS进行相应处理

#### 主存储器空间的扩充
把磁盘作为主存的扩充, 只把部分进程或进程的部分内容装入内存 **部分装入部分对换**
- 对换技术: 把部分不运行的进程调出
- 虚拟技术: 只调入进程的部分内容

这一工作需要软硬件协作完成
- 对换进程决定对换
- 硬件机构决定调入
- 当CPU处理到不在主存的地址, 发出虚拟地址异常, OS将其调入, 重新执行该指令

### 虚拟存储器的概念
为什么需要虚拟存储器
- 主存容量是有限制的, 用户编写程序时就必须考虑主存容量限制
- 多道程序设计的道数受到限制

对用户编程行为分析
- 存在顺序性和循环性等空间局部性
- 存在时间局部性
- 因此可以考虑部分装入部分对换

基本思想
- 存储管理把进程全部信息放在辅存中, 执行时先将其中一部分装入主存, 以后根据执行行为随用随调入
- 如主存中没有足够的空闲空间, 存储管理需要根据执行行为把主存中暂时不用的信息调出到辅存

实现思路
- 建立与自动管理两个地址空间
  - (辅存)虚拟地址空间: 容纳进程装入
  - (主存)实际地址空间: 承载进程执行
- 对于用户来说计算机系统具有一个容量大得多的主存空间, 即**虚拟存储器**
- 虚拟存储器是一种地址空间扩展技术

### 存储管理的硬件支持

#### 存储管理涉及的存储对象
存储管理是OS管理主存储器的**软件部分**
- 为获得更好的处理性能, 要管理Cache
- 为获得更大的虚拟地址空间, 要管理硬盘上的虚拟存储器文件

#### Cache
Cache的构成
- 高速存储器: 由SRAM组成
- 联想存储器: 根据内容进行寻址的存储器, 也就是根据tag
- 地址转换部件: 通过联想存储器建立目录表以实现快速地址转换, 命中时直接访问Cache, 未命中时从内存读取放入Cache
- 替换部件: 在Cache满时按一定策略进行数据库替换

Cache现在一般放到处理器里面, 可以分为
- L1 Cache
- L2 Cache: 有内置的也有外置的
- L3 Cache: 多为外置, 在游戏和服务器领域有效, 但对很多应用来说, 总线改善比设置L3 Cache更加有效

#### 地址转换和存储保护的硬件支持
通过一个限长寄存器和一个基址寄存器, 定义允许访问的地址范围, 并实现动态重定位

## 单连续分区存储管理
每个进程占用一个物理上完全连续的存储空间, 可以分为
- 单用户连续分区存储管理
- 固定分区存储管理
- 可变分区存储管理

### 单用户连续分区存储管理
主存区域被划分为系统区与用户区

设置一个栅栏寄存器区分两个区域, 使用硬件进行存储保护

一般采用静态重定位进行地址转换
- 在装入一个作业时, 把该作业中程序的指令地址和数据地址全部转换成绝对地址

硬件实现代价低

适用于单用户单任务操作系统, 如DOS

### 固定分区存储管理
- 支持多个分区
- 分区数量和大小都是固定的
- 可用静态重定位
- 硬件实现代价低
- 早期OS采用

如何硬件实现:
- 设置一个下限寄存器和上限寄存器
- 也可以在CPU执行指令的时候进行动态重定位, 只要设置好上下限寄存器的值

### 可变分区存储管理
固定分区存储管理不够灵活, 既不适应大尺寸程序, 又存在内存内零头浪费

可变分区存储管理
- 按进程的内存需求来动态划分分区
- 由于分区大小是按照进程实际需要来确定的, 因此分区个数是随机变化的

可变分区方式的内存分配算法
- 最先适应分配算法: 从内存开头找适配的分区
- 邻近适应分配算法: 从上一次分配的分区开始往后找
- 最优适应分配算法: 找和需要量最匹配的分区
- 最坏适应分配算法: 找和需要量最不匹配的分区

可变分区方式的内存回收
- 分区内存回收后, 相邻的空闲分区会进行merge

硬件上通过限长寄存器和基址寄存器实现


固定分区方式会产生内存内零头, 可变分区方式会产生一些小的不可用的内存分区, 称为内存外零头
- 最优适应分配算法最容易产生外零头
- 任何适配算法都不能避免产生外零头

移动技术(程序浮动技术)
- 移动分区以解决内存外零头
- 需要动态重定位支撑, 因为若采用的是静态重定位, 那么移动完分区就无法找到对应的进程了

![alt text](/assets/image5.png)



## 页式存储管理
基本原理
- 分页存储器将主存划分成多个大小相等的页框
- 受页框尺寸限制, 程序的逻辑地址也自然分成页
- 同一个程序的不同的页可以放在不同的页框中, 且彼此不需要连续
- 页表用于维系进程的主存完整性
- 每个进程都有相应的页表

页式存储管理中的逻辑地址由两部分组成
1. 页号
2. 单元号

物理地址也由两部分组成
1. 页框号
2. 单元号

地址转换通过查页表, 完成页号到页框号的映射


页式存储管理能够实现多个进程共享程序和数据
- 程序共享: 不同进程使用相同的页号共享代码页
- 数据共享: 不同进程使用不同页号共享数据页
  - 这不同的页号映射到的是同样的一个物理页框
  - 不同的页号实现读共享和写隔离, 在一个进程发生写操作时按需进行复制

### 页式存储管理的地址转换
地址转换代价
- 页表放在主存中, 每次地址转换必须访问两次主存
  - 按页号访问页表, 读出页框号
  - 计算出绝对地址访问主存进行读写
- 解决办法: 利用Cache存放部分页表

页式存储管理的快表
- 为提高地址转换速度, 设置一个专用的高速存储器, 来存放一部分页表
- 存放在高速存储器中的页表被称为快表

基于快表的地址转换流程
1. 按逻辑地址中的页号查快表
2. 若该页已在快表中, 则由页框号和单元号形成绝对地址
3. 若该页不在快表中, 则再查主存页表, 形成绝对地址, 同时将该页登记到快表中
4. 当快表填满后, 则需要按一定策略进行替换

多道程序环境下的进程表
- 进程表中登记了每个进程的页表
- 当进程占有处理器运行时, 其页表起始地址和长度送入**页表控制寄存器**

### 分页的寻址计算
根据页大小, 划分逻辑地址中的页号和单元号, 根据页号到页表中找页框号, 一般页框和页是一样大的, 那么物理地址就是页框号对应的页框起始地址和单元号的组合


### 页式虚拟存储管理
虚拟存储器在分页下的运行情况

抖动现象
- 如果一块正好将要被用到的页框, 在用到之前扔出
- 操作系统又不得不很快把它取回
- 过多的这样的操作会导致系统抖动
- 在处理缺页中断期间, 处理器的大部分时间都用于交换块, 而不是用户进程的执行指令

页式虚拟存储管理的基本思想
- 把进程全部页面装入虚拟存储器
- 执行时先把部分页面装入实际内存
- 然后根据执行行为, 动态调入不在主存的页, 同时进行页面调出
- 是现代OS的主流存储管理技术
- 首次只把进程第一页信息装入主存, 称为请求页式存储管理

需要扩充页表项
- 每页的实际地址(在辅助存储器地址), 当发生缺页的时候要去哪里调入这个页
- 主存驻留标志: 是否在主存中
- 写回标志: 是否发生了改变, 需要写回辅助存储器
- 保护标志, 引用标志, 可移动标志

页式虚拟存储管理的实现
- CPU处理地址
  - 若页驻留主存, 则获得页框号, 计算绝对地址
  - 若页不在内存, 则CPU发出缺页中断
- OS处理缺页中断
  - 若有空闲页框, 则根据辅存地址调入页, 更新页表与快表
  - 若无空闲页框, 则决定替换页

### 页面调度
当主存空间已满, 而又需要装入新页时, 页式虚拟存储管理必须按照一定的算法把已在主存的一些页调出去

若页面调度算法设计不当, 就会出现抖动现象

缺页中断率: 类比cache的命中率

影响缺页中断率的因素
- 分配给进程的页框数
- 页面的大小
- 用户的程序编写方式

#### OPT页面调度算法
理想的调度算法, 由Belady提出, 称为Belady算法, 又称最佳算法
- 当要调入新页面时, 首先淘汰以后不再访问的页, 然后选择距现在最长时间后再访问的页

现实中我们无法预知以后页面的使用情况, 所以是理想的

#### FIFO页面调度算法
先进先出, 总是淘汰最先调入主存的页, 模拟的是程序执行的顺序性

#### LRU页面调度算法
最近最少用, 淘汰**最近一段时间**较久未被访问的页, 即那些刚被使用过的页面, 可能马上还要被使用, 模拟程序执行的局部性
- 为每个页面建立一个引用标志, 供硬件使用
- 设置一个时间间隔中断: 中断时页引用标志置0
- 地址转换时, 即被使用到了, 页引用标志置1
- 淘汰页面时从页引用标志为0的页中随机选择
- 时间间隔多长是一个难点

#### LFU页面调度算法
最不常用, 淘汰最近一段时间内访问次数比较少的页面, 对OPT的模拟性比LRU更好
- 基于时间间隔中断, 并给每个页面设置一个计数器
- 发生时间间隔中断后, 所有计数器清0
- 每访问页1次就给计数器加1
- 选择计数值最小的页面淘汰

#### CLOCK页面调度算法
时钟, 采用循环队列构造页面的一个队列, 队列指针指向可能要淘汰的页面, 使用页引用标志位
- 页面调入主存时, 其引用标志位置1
- 访问主存页面时, 其引用标志位置1
- 需要淘汰页面时, 从队列指针当前指向的页面开始循环扫描队列
  - 把标志位为1的页面清0, 并跳过
  - 把标志位为0的页面淘汰, 指针推进一步

#### 局部页面调度算法

##### 局部最佳页面调度算法 MIN
- 进程在时刻t访问某页面, 如果页面不在主存中, 导致一次缺页, 把该页面装入一个空闲页框
- 无论是否发生缺页, 接下来都要考虑引用串, 如果某页面在时间间隔$(t, t+ \tau)$ 内未被再次引用, 那么就移出, 否则保留

##### 工作集置换算法 WorkList
进程工作集指在某一时间间隔内进程运行所需访问的页面集合 $W(t, \Delta)$表示在时刻$t - \Delta$ 到时刻$t$之间所访问的页面集合, 是进程在时刻$t$的工作集

实现思想
- 不向未来查看页面引用串, 而是基于程序局部性原理向过去看, 不在工作集的被移出
- 任何给定时刻, 进程不久的将来所需主存页框数, 可以通过考察其过去最近的时间内的主存需求做出估计

$\Delta$是系统定义的一个常量, 称为工作集窗口尺寸, 可通过窗口来观察进程行为, 还把工作集中所包含的页面数目称为工作集尺寸

通过工作集确定驻留集大小
1. 监视每个进程的工作集, 只有属于工作集的页面才能留在主存
2. 定期地从进程驻留集中删去那些不在工作集的页面
3. 仅当一个进程的工作集在主存时, 进程才能执行

#### Belady异常
一个进程能拥有更多的页框, 但反而发生了更多的缺页

主要发生在FIFO页面调度算法

为什么会发生Belady异常？

根本原因在于 FIFO算法的置换策略与程序访问页面的顺序存在冲突。以下是具体解释：

1. FIFO算法的局限性: FIFO算法在置换页面时只考虑页面进入内存的时间，而忽略页面的访问频率或重要性。它总是选择最早进入内存的页面进行置换，无论该页面是否即将被再次访问。

2. 新增页框的副作用:当进程获得更多页框时，FIFO算法可能会：
   1. 保留本应被置换的“老旧”页面：新增的页框允许更多页面驻留内存，但其中可能包含一些早期加载、后续不再访问的“无用”页面。
   2. 提前移出“关键”页面：某些页面虽然较早进入内存，但后续会被频繁访问。新增页框后，这些页面因“年龄大”反而被FIFO优先置换出去，导致后续访问时触发缺页。

#### 页大小的设计
- 更小的页大小, 能减少页的内部零头浪费
- 更小的页大小, 那每个进程需要的页的数量就变多
- 更多的页数量就会导致更大的页表, 占据虚拟内存的比例就增加
- 磁盘那样的设备被设计成能有效读取大尺寸的数据, 对于大的页更有利
- 多种页面大小能提升TLB效率
- 但现在大多数的OS只支持一种页面大小

### 伙伴系统
伙伴系统, 又称buddy算法, 是一种固定分区和可变分区折中的主存管理算法
- 任何尺寸为$2^i$的空闲块, 可以被分为两个尺寸为$2^{i-1}$的空闲块
- 这两个空闲块被称为伙伴, 可以被合并

#### Linux基于伙伴的slab分配器
为什么要使用slab分配器
- 伙伴系统以页框为基本分配单位, 内核在很多情况下,需要的主存量远远小于页框大小
- slab分配器为经常使用的小对象建立缓存, 小对象的申请与释放都通过slab分配器管理, 仅当缓存不够用时才向伙伴系统申请更多空间


### 反置页表
为什么需要多级页表
- 现代计算机普遍支持$2^{32}$ ~ $2^{64}$的逻辑地址空间, 采用分页存储管理时, 页表相当大 *以Windows为例，其运行的Intel x86平台具有32位地址，规定页面4KB(212)时，那么，4GB($2^{32}$)的逻辑地址空间由1兆($2^{20}$)个页组成，若每个页表项占用4个字节，则需要占用4MB($2^{22}$)连续主存空间存放页表。系统中有许多进程，每个进程都有一个页表因此页表存储开销很大*

多级页表的概念
- 系统为每个进程创建一张页目录表, 它的每个表项对应一个页表页, 页表页的每个表项给出页面和页框的对应. 页目录是一级页表, 页表是二级页表
- 这样逻辑地址就分为三部分: 页目录, 页表页, 位移

这只是二级页表, 还可以有三级, 空间减少的同时, 自然也增加了寻址时间. **是很典型的时间与空间的矛盾**

多级页表结构的本质
- 多级不连续结构, 导致多级索引
- 用户程序的页面是不连续的放在页框内, 那页面就需要索引, 这是进程页表
- 每个进程的进程页表又是不连续存放的, 那页表就需要页目录索引

#### 反置页表的提出
页表及相关的硬件机制在地址转换, 存储保护, 虚拟地址访问中发挥了关键作用

计算机为页式存储管理设置了专门硬件结构

内存管理单元MMU
- CPU管理虚拟/物理存储器的控制线路
- 把虚拟地址映射为物理地址, 并提供存储保护
- 必要时确定淘汰页面

反置页表IPT: MMU用的数据结构
- 针对内存中的每个页框建立一个页表, 按照页框号(块号)排序
- 表项包含: 正在访问该页框的进程标识, 页号及特征位, 和哈希链指针
- 用来完成内存页框到访问进程页号的对应, 即物理地址到逻辑地址的转换, 所以被称之为反置页表

MMU基于反置页表的地址转换过程
- MMU通过哈希表把进程标识和虚页号转换成一个哈希值, 指向IPT的一个表目
- MMU遍历哈希链找到所需进程的虚页号, 在IPT中的索引就是页框号, 通过拼接便可生成物理地址
- 若遍历过程没有找到匹配的页表项, 说明该页不在内存, 产生缺页中断, 请求操作系统调入 **也是一个软硬件协同的例子**

反置页表和正向页表的差别就在于, 反置页表的大小是固定的, 和虚拟地址空间无关, 虚拟地址是通过Hash(以虚拟地址为key, 实际物理页框号为value)映射到哈希表中, 这个哈希表的大小是由主存空间中页框的数量确定的.

## 段式存储管理

段式程序设计
- 每个程序可由若干段组成, 每一段都可以从0开始编址, 段内的地址是连续的
- 分段存储器的逻辑地址由两部分组成: 段号和单元号


段式存储管理的基本思想
- 段式存储管理基于可变分区存储管理实现, 一个进程占用多个分区
- 硬件需要增加一组用户可见的段地址寄存器, 供地址转换使用
- 存储管理需要增加设置一个段表, 每个段占用一个段表项
  - 段起始地址
  - 段限制长度
  - 存储保护, 可移动, 可扩充等标志位

![alt text](/assets/image6.png)


段的共享
- 通过不同进程段表中的项指向同一个段基址实现 (类似页的共享)
- 对共享段的信息必须进行保护, 如规定只能读出不能写入, 不满足保护条件则产生保护中断

### 段式虚拟存储管理
基本思想
- 把进程的所有分段都存放在辅存中, 进程运行时先把当前需要的一段或几段装入主存, 在执行过程中访问到不在主存的段时再把他们动态装入
- 段的调进调出由OS自动实现
- 与段覆盖技术不同, 段覆盖技术是用户控制的主存扩充技术, OS不感知

#### 段页式存储管理
基本思想
- 段式存储管理可以基于页式存储管理实现
- 每一段不必占据连续的存储空间, 可存放在不连续的主存页框中
- 能够扩充为段页式虚拟存储管理
- 装入部分段, 或装入段中部分页面

地址转换
- 由段号根据段表查找第i段的页表位置
- 由页号在内存中对应的i段页表查找对应的页框起始地址
- 在和单元号拼接

分段的寻址计算: 和分页的寻址计算类似

分段和分页的比较:
- 分段是信息的逻辑单位, 由源程序的逻辑结构所决定, 用户可见
- 段长可根据用户需要来规定, 段起始地址可从主存任意地方开始
- 分段方式中, 源程序(段号, 段内偏移)经连接装配后地址仍保持二维结构
- 分页是信息的物理单位, 与源程序的逻辑结构无关, 用户不可见
- 页长由系统确定, 页面只能以页大小的整数倍地址开始
- 分页方式中, 源程序(页号, 页内偏移)经连接装配后变成了一维结构